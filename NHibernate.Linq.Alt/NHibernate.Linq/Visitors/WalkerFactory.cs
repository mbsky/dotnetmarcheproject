using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Linq.Expressions;
using NHex = NHibernate.Expressions;

namespace NHibernate.Linq.Visitors
{
    class WalkerFactory
    {
        protected ICriteria rootCriteria;
        internal WalkerFactory(ICriteria criteria)
        {
            rootCriteria = criteria;
        }

        internal MemberAccessWalker FromMemberAccessNode(MemberExpression exp)
        {
            return new MemberAccessWalker(exp.Member.Name, exp.Type, rootCriteria);
        }

        internal ConstructorWalker FromConstrucorNode(NewExpression exp)
        {
            return new ConstructorWalker(exp.Constructor, rootCriteria);
        }

        internal ConstantWalker FromConstantNode(ConstantExpression exp)
        {
            return FromConstant(exp.Value);
        }

        /// <summary>
        /// Construct the walker based on method call.
        /// Note1: The IDbMethods is a marker interface, each dialect extend with
        /// a series of extension methods. Every method thats accepts a IDbmethods
        /// as first interface is to be called directly on db.
        /// </summary>
        /// <param name="exp"></param>
        /// <returns></returns>
        internal Walker FromMethodCall(MethodCallExpression exp)
        {
            if (exp.Method.Name == "StartsWith" && exp.Method.ReflectedType == typeof(String))
                return new StringFunctionsWalker(
                    StringFunctionsWalker.StringFunction.StartsWith,
                    rootCriteria);
            else if (exp.Method.Name == "EndsWith" && exp.Method.ReflectedType == typeof(String))
                return new StringFunctionsWalker(
                    StringFunctionsWalker.StringFunction.EndsWith,
                    rootCriteria);
            else if (exp.Method.Name == "Contains" && exp.Method.ReflectedType == typeof(String))
                return new StringFunctionsWalker(
                    StringFunctionsWalker.StringFunction.Contains,
                    rootCriteria);
            else if (exp.Method.Name == "Any")
                if (exp.Method.GetParameters().Length == 2)
                    return new AnyWalker(rootCriteria);
                else
                    return  new UnaryAnyWalker(rootCriteria);
            //Note1
            else if (exp.Method.GetParameters()[0].ParameterType == typeof(NHibernate.Linq.IDbMethods))
                return new SqlFunctionWalker(exp.Method.Name, exp.Method.GetParameters().Length, rootCriteria);
            else if (exp.Method.DeclaringType == typeof(NHibernateExtensions))
                return null; //NhibernateExtensions contains extension methods, ignore it
            else if (exp.Method.DeclaringType == typeof(Enumerable))
                return new CastWalker(exp.Method.GetGenericArguments()[0], rootCriteria);
            else
                throw new NotImplementedException("Not implemented");
        }



        /// <summary>
        /// Pay attenction to the DisplayClasses generated by linq, these classes are used
        /// when you reference a variable outside the expression, these are anonymous method with
        /// only one field that references the real variable.
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        internal ConstantWalker FromConstant(Object value)
        {
            return FromConstant(value, rootCriteria);
        }

        internal static ConstantWalker FromConstant(Object value, ICriteria rootCriteria)
        {
            //if (value == null) return new ConstantWalker(null, rootCriteria);

            //System.Type ty = value.GetType();
            //Object realValue = value;
            //if (ty.FullName.Contains("__DisplayClass"))
            //{
            //    realValue = ty.GetFields()[0].GetValue(value);
            //}
            return new ConstantWalker(value, rootCriteria);
        }

        internal NotWalker Not()
        {
            return new NotWalker(rootCriteria);
        }

        internal BinaryWalker FromBinary(BinaryExpression exp)
        {
            Func<String, Object, NHex.ICriterion> f;
            switch (exp.NodeType)
            {
                case ExpressionType.Equal:
                case ExpressionType.NotEqual:
                    return FromLambda(f = (s, o) => NHex.Expression.Eq(s, o), (s, o) => NHex.Expression.EqProperty(s, o));
                case ExpressionType.GreaterThan:
                    return FromLambda(f = (s, o) => NHex.Expression.Gt(s, o), (s, o) => NHex.Expression.GtProperty(s, o));
                case ExpressionType.GreaterThanOrEqual:
                    return FromLambda(f = (s, o) => NHex.Expression.Ge(s, o), (s, o) => NHex.Expression.GeProperty(s, o));
                case ExpressionType.LessThan:
                    return FromLambda(f = (s, o) => NHex.Expression.Lt(s, o), (s, o) => NHex.Expression.LtProperty(s, o));
                case ExpressionType.LessThanOrEqual:
                    return FromLambda(f = (s, o) => NHex.Expression.Le(s, o), (s, o) => NHex.Expression.LeProperty(s, o));
                //case ExpressionType.NotEqual:
                //    return FromLambdaNegated(f = (s, o) => NHex.Expression.Not(NHex.Expression.Eq(s, o)));

                //Then some logic operator of conjuncion and disjunction
                case ExpressionType.And:
                case ExpressionType.AndAlso:
                    return new AndWalker(rootCriteria);
                case ExpressionType.Or:
                case ExpressionType.OrElse:
                    return new OrWalker(rootCriteria);
                default:
                    throw new NotImplementedException("Not implemented");
            }
        }

        private BinaryWalker FromLambda(
            Func<String, Object, NHex.ICriterion> f, 
            Func<String, String, NHex.ICriterion> fp)
        {
            return new BaseBinaryOperatorWalker(f, fp , rootCriteria);
        }
    }
}
